# Auto generated by LangBot Plugin SDK.
# Please refer to https://docs.langbot.app/en/plugin/dev/tutor.html for more details.
from __future__ import annotations

import asyncio
import requests
import os
from langbot_plugin.api.definition.components.common.event_listener import EventListener
from langbot_plugin.api.entities import events, context
from langbot_plugin.api.entities.builtin.platform import message as platform_message
from langbot_plugin.api.entities.builtin.provider import message as provider_message
# å¯¼å…¥éŸ³ä¹å¡ç‰‡å‘é€å·¥å…·
from utils.music_card import MusicCardSender

class DefaultEventListener(EventListener):
    # å­˜å‚¨ç”¨æˆ·çš„æœç´¢ç»“æœå’ŒçŠ¶æ€
    user_searches = {}
    # éŸ³ä¹å¡ç‰‡å‘é€å™¨å®ä¾‹
    music_card_sender = None
    # NapCaté…ç½®
    napcat_http_url = "http://127.0.0.1:3000"  # NapCat HTTP APIåœ°å€é»˜è®¤å€¼
    napcat_access_token = None  # è®¿é—®ä»¤ç‰Œï¼ˆå¦‚æœéœ€è¦çš„è¯ï¼‰
    
    async def initialize(self):
        await super().initialize()

        # åˆå§‹åŒ–éŸ³ä¹å¡ç‰‡å‘é€å™¨
        # å¯ä»¥ä»ç¯å¢ƒå˜é‡æˆ–é…ç½®æ–‡ä»¶è¯»å–NapCaté…ç½®
        self.napcat_http_url = self.plugin.get_config('napcat_url', self.napcat_http_url)
        napcat_url = os.getenv('NAPCAT_HTTP_URL', self.napcat_http_url)
        napcat_token = os.getenv('NAPCAT_ACCESS_TOKEN', self.napcat_access_token)

        self.music_card_sender = MusicCardSender(
            http_url=napcat_url,
            access_token=napcat_token
        )
        
        @self.handler(events.PersonMessageReceived)
        @self.handler(events.GroupMessageReceived)
        async def handler(event_context: context.EventContext):
            # è·å–æ¶ˆæ¯å†…å®¹
            message_chain = event_context.event.message_chain
            message = "".join(
                element.text for element in message_chain
                if isinstance(element, platform_message.Plain)
            ).strip()
            
            # è·å–ç”¨æˆ·ID
            user_id = str(event_context.event.sender_id)
            
            # æ£€æŸ¥æ˜¯å¦æ˜¯é€‰æ‹©æ­Œæ›²çš„æ•°å­—
            if user_id in self.user_searches and message.isdigit():
                # ç”¨æˆ·åœ¨é€‰æ‹©æ­Œæ›²
                song_index = int(message) - 1
                search_results = self.user_searches.get(user_id, [])
                
                if 0 <= song_index < len(search_results):
                    # è·å–é€‰æ‹©çš„æ­Œæ›²ä¿¡æ¯
                    song_info = search_results[song_index]
                    # è°ƒç”¨APIè·å–æ­Œæ›²è¯¦æƒ…ï¼Œä½¿ç”¨song_titleå’Œnå‚æ•°
                    song_detail = await self.get_song_detail(song_info['song_name'], song_info['n'])
                    
                    # ç§»é™¤ç”¨æˆ·çš„æœç´¢è®°å½•
                    if user_id in self.user_searches:
                        del self.user_searches[user_id]
                    
                    # å¤„ç†æ­Œæ›²è¯¦æƒ…ä¿¡æ¯
                    data = song_detail.get('data', {})
                    cover_url = data.get('cover', '')
                    music_url = data.get('music_url', '')
                    link_ = data.get('link', '')

                    # æ¸…ç†å¯èƒ½åŒ…å«çš„é¢å¤–å­—ç¬¦ï¼ˆå¦‚ç©ºæ ¼å’Œåå¼•å·ï¼‰
                    cover_url = cover_url.strip(' `')
                    music_url = music_url.strip(' `')

                    # åˆ¤æ–­æ¶ˆæ¯æ¥æºï¼ˆç¾¤èŠè¿˜æ˜¯ç§èŠï¼‰
                    if isinstance(event_context.event, events.GroupMessageReceived):
                        target_type = 'group'
                        target_id = event_context.event.group_id
                    else:
                        target_type = 'private'
                        target_id = event_context.event.sender_id

                    # å°è¯•é€šè¿‡NapCatå‘é€éŸ³ä¹å¡ç‰‡
                    if self.music_card_sender:
                        try:
                            # å‘é€éŸ³ä¹å¡ç‰‡
                            card_result = await self.music_card_sender.send_custom_music_card(
                                target_id=target_id,
                                target_type=target_type,
                                title=f"{song_info['song_name']} - {song_info['song_singer']}",
                                audio_url=music_url,
                                jump_url=link_,
                                image_url=cover_url,
                                content=f"ç”± musicLink æä¾›"
                            )

                            if card_result.get('success'):
                                # éŸ³ä¹å¡ç‰‡å‘é€æˆåŠŸï¼Œå‘é€é¢å¤–çš„æ–‡å­—ä¿¡æ¯
                                await event_context.reply(
                                    platform_message.MessageChain([
                                        platform_message.Plain(text=f"âœ… éŸ³ä¹å¡ç‰‡å·²å‘é€\n"),
                                        platform_message.Plain(text=f"ğŸ“± å¤‡ç”¨ä¸‹è½½é“¾æ¥ï¼š{music_url}\n"),
                                    ])
                                )
                            else:
                                # å¡ç‰‡å‘é€å¤±è´¥ï¼Œå›é€€åˆ°ä¼ ç»Ÿæ–¹å¼
                                raise Exception(f"Music card send failed: {card_result.get('error', 'Unknown')}")
                        except Exception as e:
                            # å¦‚æœå¡ç‰‡å‘é€å¤±è´¥ï¼Œä½¿ç”¨ä¼ ç»Ÿæ–¹å¼å‘é€
                            print(f"éŸ³ä¹å¡ç‰‡å‘é€å¤±è´¥ï¼Œä½¿ç”¨ä¼ ç»Ÿæ–¹å¼: {str(e)}")
                            # ä½¿ç”¨éŸ³ä¹ä¸‹è½½é“¾æ¥ä½œä¸ºåœ¨çº¿è¯•å¬é“¾æ¥
                            listen_url = link_

                            await event_context.reply(
                                platform_message.MessageChain([
                                    platform_message.Image(url=cover_url),
                                    platform_message.Plain(text=f"æ­Œæ›²ï¼š{song_info['song_name']}\n"),
                                    platform_message.Plain(text=f"æ­Œæ‰‹ï¼š{song_info['song_singer']}\n"),
                                    platform_message.Plain(text=f"åœ¨çº¿è¯•å¬é“¾æ¥ï¼š{listen_url}\n"),
                                    platform_message.Plain(text=f"éŸ³ä¹ä¸‹è½½é“¾æ¥ï¼š{music_url}\n"),
                                ])
                            )
                    else:
                        # æ²¡æœ‰é…ç½®éŸ³ä¹å¡ç‰‡å‘é€å™¨ï¼Œä½¿ç”¨ä¼ ç»Ÿæ–¹å¼
                        listen_url = link_

                        await event_context.reply(
                            platform_message.MessageChain([
                                platform_message.Image(url=cover_url),
                                platform_message.Plain(text=f"æ­Œæ›²ï¼š{song_info['song_name']}\n"),
                                platform_message.Plain(text=f"æ­Œæ‰‹ï¼š{song_info['song_singer']}\n"),
                                platform_message.Plain(text=f"åœ¨çº¿è¯•å¬é“¾æ¥ï¼š{listen_url}\n"),
                                platform_message.Plain(text=f"éŸ³ä¹ä¸‹è½½é“¾æ¥ï¼š{music_url}\n"),
                            ])
                        )
                    event_context.prevent_default()
                else:
                    await event_context.reply(
                        platform_message.MessageChain([
                            platform_message.Plain(text="æ— æ•ˆçš„é€‰æ‹©ï¼Œè¯·è¾“å…¥æ­£ç¡®çš„åºå·ï¼"),
                        ])
                    )
                    event_context.prevent_default()
                return
            
            # æ£€æŸ¥æ˜¯å¦åŒ…å«"ç‚¹æ­Œ"æŒ‡ä»¤
            if message.startswith("ç‚¹æ­Œ"):
                # æå–æ­Œæ›²åç§°
                song_name = message[2:].strip()
                if not song_name:
                    await event_context.reply(
                        platform_message.MessageChain([
                            platform_message.Plain(text="è¯·è¾“å…¥è¦ç‚¹æ’­çš„æ­Œæ›²åï¼Œæ ¼å¼ï¼šç‚¹æ­Œ+æ­Œæ›²å"),
                        ])
                    )
                    return
                
                # æœç´¢æ­Œæ›²
                try:
                    search_results = await self.search_music(song_name)
                    
                    if not search_results:
                        await event_context.reply(
                            platform_message.MessageChain([
                                platform_message.Plain(text=f"æœªæ‰¾åˆ°æ­Œæ›²ï¼š{song_name}"),
                            ])
                        )
                        event_context.prevent_default()
                        return
                    
                    # ä¿å­˜æœç´¢ç»“æœ
                    self.user_searches[user_id] = search_results[:10]  # æœ€å¤šä¿å­˜å‰10é¦–
                    
                    # æ„å»ºå›å¤æ¶ˆæ¯
                    reply_text = f"æ‰¾åˆ°ä»¥ä¸‹{min(len(search_results), 10)}é¦–æ­Œæ›²ï¼Œè¯·åœ¨5ç§’å†…å›å¤åºå·é€‰æ‹©ï¼š\n"
                    for i, song in enumerate(search_results[:10]):
                        reply_text += f"{i+1}. {song['song_name']} - {song['song_singer']}\n"
                    reply_text += "5ç§’åå°†è‡ªåŠ¨å–æ¶ˆé€‰æ‹©ã€‚"
                    
                    await event_context.reply(
                        platform_message.MessageChain([
                            platform_message.Plain(text=reply_text),
                        ])
                    )
                    event_context.prevent_default()
                    
                    # å¯åŠ¨5ç§’å€’è®¡æ—¶ä»»åŠ¡
                    asyncio.create_task(self.clear_user_search(user_id, 5))
                    
                except Exception as e:
                    await event_context.reply(
                        platform_message.MessageChain([
                            platform_message.Plain(text=f"æœç´¢æ­Œæ›²æ—¶å‡ºé”™ï¼š{str(e)}"),
                        ])
                    )
    
    async def search_music(self, song_name):
        """æœç´¢éŸ³ä¹"""
        try:
            url = "http://lpz.chatc.vip/apiqq.php"
            params = {
                'msg': song_name,
                'type': 'json',
                'num': '10'
            }
            
            # å‘é€è¯·æ±‚
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()  # æ£€æŸ¥HTTPçŠ¶æ€ç 
            
            # è§£æJSON
            data = response.json()
            # print(f"æœç´¢éŸ³ä¹APIå“åº”: {data}")
            # æ£€æŸ¥çŠ¶æ€ç å’Œæ•°æ®æ ¼å¼
            if data.get('code') == 200 and isinstance(data.get('data'), list):
                # ç¡®ä¿è¿”å›çš„æ¯ä¸ªå…ƒç´ éƒ½æœ‰å¿…è¦çš„å­—æ®µ
                valid_songs = []
                for song in data.get('data', []):
                    if isinstance(song, dict) and all(k in song for k in ['n', 'song_title', 'song_singer']):
                        # é‡å‘½åå­—æ®µä»¥ä¿æŒä¸€è‡´æ€§
                        valid_songs.append({
                            'n': song['n'],
                            'song_name': song['song_title'],
                            'song_singer': song['song_singer']
                        })
                return valid_songs
            else:
                return []
        except Exception as e:
            print(f"æœç´¢éŸ³ä¹å‡ºé”™: {str(e)}")
            return []
    
    async def get_song_detail(self, song_title, song_n):
        """è·å–æ­Œæ›²è¯¦æƒ…"""
        try:
            url = "http://lpz.chatc.vip/apiqq.php"
            params = {
                'msg': song_title,
                'n': song_n,
                'type': 'json',
                'br': '1'  # ä½¿ç”¨æœ€é«˜éŸ³è´¨
            }
            
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"è·å–æ­Œæ›²è¯¦æƒ…å‡ºé”™: {str(e)}")
            # è¿”å›é»˜è®¤ç»“æ„ï¼Œç¡®ä¿å³ä½¿å‡ºé”™ä¹Ÿèƒ½ç»§ç»­è¿è¡Œ
            return {'code': 500, 'data': {}}

    
    async def clear_user_search(self, user_id, delay):
        """å»¶è¿Ÿæ¸…é™¤ç”¨æˆ·æœç´¢è®°å½•"""
        await asyncio.sleep(delay)
        if user_id in self.user_searches:
            del self.user_searches[user_id]