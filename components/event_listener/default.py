# Auto generated by LangBot Plugin SDK.
# Please refer to https://docs.langbot.app/en/plugin/dev/tutor.html for more details.
from __future__ import annotations

import asyncio
import requests
from langbot_plugin.api.definition.components.common.event_listener import EventListener
from langbot_plugin.api.entities import events, context
from langbot_plugin.api.entities.builtin.platform import message as platform_message
from langbot_plugin.api.entities.builtin.provider import message as provider_message

class DefaultEventListener(EventListener):
    # 存储用户的搜索结果和状态
    user_searches = {}
    
    async def initialize(self):
        await super().initialize()
        
        @self.handler(events.PersonMessageReceived)
        @self.handler(events.GroupMessageReceived)
        async def handler(event_context: context.EventContext):
            # 获取消息内容
            message_chain = event_context.event.message_chain
            message = "".join(
                element.text for element in message_chain
                if isinstance(element, platform_message.Plain)
            ).strip()
            
            # 获取用户ID
            user_id = str(event_context.event.sender_id)
            
            # 检查是否是选择歌曲的数字
            if user_id in self.user_searches and message.isdigit():
                # 用户在选择歌曲
                song_index = int(message) - 1
                search_results = self.user_searches.get(user_id, [])
                
                if 0 <= song_index < len(search_results):
                    # 获取选择的歌曲信息
                    song_info = search_results[song_index]
                    # 调用API获取歌曲详情，使用song_title和n参数
                    song_detail = await self.get_song_detail(song_info['song_name'], song_info['n'])
                    
                    # 移除用户的搜索记录
                    if user_id in self.user_searches:
                        del self.user_searches[user_id]
                    
                    # 处理歌曲详情信息
                    data = song_detail.get('data', {})
                    cover_url = data.get('cover', '')
                    music_url = data.get('music_url', '')
                    link_ = data.get('link', '')
                    
                    # 清理可能包含的额外字符（如空格和反引号）
                    cover_url = cover_url.strip(' `')
                    music_url = music_url.strip(' `')
                    
                    
                    # 发送歌曲信息
                    # 使用音乐下载链接作为在线试听链接
                    listen_url = link_
                    
                    await event_context.reply(
                        platform_message.MessageChain([
                            platform_message.Image(url=cover_url),
                            platform_message.Plain(text=f"歌曲：{song_info['song_name']}\n"),
                            platform_message.Plain(text=f"歌手：{song_info['song_singer']}\n"),
                            platform_message.Plain(text=f"在线试听链接：{listen_url}\n"),
                            platform_message.Plain(text=f"音乐下载链接：{music_url}\n"),
                        ])
                    )
                    event_context.prevent_default()
                else:
                    await event_context.reply(
                        platform_message.MessageChain([
                            platform_message.Plain(text="无效的选择，请输入正确的序号！"),
                        ])
                    )
                    event_context.prevent_default()
                return
            
            # 检查是否包含"点歌"指令
            if message.startswith("点歌"):
                # 提取歌曲名称
                song_name = message[2:].strip()
                if not song_name:
                    await event_context.reply(
                        platform_message.MessageChain([
                            platform_message.Plain(text="请输入要点播的歌曲名，格式：点歌+歌曲名"),
                        ])
                    )
                    return
                
                # 搜索歌曲
                try:
                    search_results = await self.search_music(song_name)
                    
                    if not search_results:
                        await event_context.reply(
                            platform_message.MessageChain([
                                platform_message.Plain(text=f"未找到歌曲：{song_name}"),
                            ])
                        )
                        event_context.prevent_default()
                        return
                    
                    # 保存搜索结果
                    self.user_searches[user_id] = search_results[:10]  # 最多保存前10首
                    
                    # 构建回复消息
                    reply_text = f"找到以下{min(len(search_results), 10)}首歌曲，请在5秒内回复序号选择：\n"
                    for i, song in enumerate(search_results[:10]):
                        reply_text += f"{i+1}. {song['song_name']} - {song['song_singer']}\n"
                    reply_text += "5秒后将自动取消选择。"
                    
                    await event_context.reply(
                        platform_message.MessageChain([
                            platform_message.Plain(text=reply_text),
                        ])
                    )
                    event_context.prevent_default()
                    
                    # 启动5秒倒计时任务
                    asyncio.create_task(self.clear_user_search(user_id, 5))
                    
                except Exception as e:
                    await event_context.reply(
                        platform_message.MessageChain([
                            platform_message.Plain(text=f"搜索歌曲时出错：{str(e)}"),
                        ])
                    )
    
    async def search_music(self, song_name):
        """搜索音乐"""
        try:
            url = "http://lpz.chatc.vip/apiqq.php"
            params = {
                'msg': song_name,
                'type': 'json',
                'num': '10'
            }
            
            # 发送请求
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()  # 检查HTTP状态码
            
            # 解析JSON
            data = response.json()
            # print(f"搜索音乐API响应: {data}")
            # 检查状态码和数据格式
            if data.get('code') == 200 and isinstance(data.get('data'), list):
                # 确保返回的每个元素都有必要的字段
                valid_songs = []
                for song in data.get('data', []):
                    if isinstance(song, dict) and all(k in song for k in ['n', 'song_title', 'song_singer']):
                        # 重命名字段以保持一致性
                        valid_songs.append({
                            'n': song['n'],
                            'song_name': song['song_title'],
                            'song_singer': song['song_singer']
                        })
                return valid_songs
            else:
                return []
        except Exception as e:
            print(f"搜索音乐出错: {str(e)}")
            return []
    
    async def get_song_detail(self, song_title, song_n):
        """获取歌曲详情"""
        try:
            url = "http://lpz.chatc.vip/apiqq.php"
            params = {
                'msg': song_title,
                'n': song_n,
                'type': 'json',
                'br': '1'  # 使用最高音质
            }
            
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"获取歌曲详情出错: {str(e)}")
            # 返回默认结构，确保即使出错也能继续运行
            return {'code': 500, 'data': {}}

    
    async def clear_user_search(self, user_id, delay):
        """延迟清除用户搜索记录"""
        await asyncio.sleep(delay)
        if user_id in self.user_searches:
            del self.user_searches[user_id]